1.继承的语法
      class BaseClass{...}
      class DerivedClass extend BaseClass{...}
    可以认为在派生类中暗含着一个基类的对象（想象）
   对象包含属性
   派生类中既有父类的属性，也有派生类的属性

   由访问控制权限来决定派生类是否可以访问基类的属性
public:基类又访问权限                  package-private:只要在一个包内，就可以访问
protected:基类有访问权限            private:没有

方法：
  基类的方法，派生类可以直接使用（在有访问权限的前提下）
  派生类是可以覆写基类的方法（override）
   1.方法名要一样
   2.参数列表要一样
   3.返回类型要一样或者是父类的返回类型的子类型
   4.访问限定不可以更严格

对象初始化
    1.父类对象（想象中的）初始化一定发生在子类对象的初始化之前
    2.定义时初始化是同等地位构造代码块，执行顺序值和定义顺序有关

类加载+对象构造顺序
    1.优先执行父类的加载
    按照书写顺序，依次执行静态构造代码块和静态属性的初始化    
    2.类的加载一定会发生该类的对象构造之前
    3.对象的构造，父类的对象构造发生子类的对象之前
            1.按照书写顺序，依次执行构造代码块和属性的初始化
            2.执行类的构造方法
    4.类只有用到的时候才会加载类
通过名字来区别谁是谁的
 extend
super关键字
     1.明确访问父类属性或方法
     2.super用来明确调用父类的构造方法
          如果父类是无参构造方法，通常来说不用明确写super（）；编译器会添加
          只有调用父类的构造方法时，必须用super关键字
        this                                     super
调用其它构造方法               调用父类构造方法
访问本类属性/方法             访问父类属性/方法
代表当前对象


对态
1.父类型的引用可以指向子类型的对象
Base b = new Derived();
2.调用方法，或者访问属性时，只看右边的对象是什么类型 和左边引用类型无关
3.静态方法和静态属性不是这个规则是看左边的引用类型

只允许单继承
abstract 修饰 class/抽象类      无法构建对象的类
abstract 修饰method/抽象方法   含有抽象方法的类必须是抽象类
必须留给子类去实现

不能让子类实现
final 修饰 class/最终类      不能有子类
final 修饰 method/最终方法      不能被子类覆写/有final方法的类不一定是final类
final的修饰属性
接口
定义interface接口名称{
     int method（）；          //隐含public+absract
}
      //接口继承是允许多继承
        interface 接口名称 extends 接口1，接口2{
}
实现接口
class 类名称 extend 基类 implement{
}
静态内部类
       作为成员的定义的类，并且被static修饰
        
       和普通的顶级类没有区别，唯一的区别就是名字上有区别

成员内部类
       作为成员定义，没有被static修饰
        
       和一个外部类对象有绑定关系

       外部类对象           <-----   内部类对象               
       所有的内部类一定会绑定一个外部类
      1.不能直接定义静态属性或方法
      2.构造内部类对象
             如果在外部类中     new Inner（）；
             如果在外部类外（或者外部类的静态上下文）
       OutClass.InnerClass = new OutClass().new InnerClass();
                                         对象

